Tipit protocol, a cheap way of implementing tipping

TODO Motivation, tipping is not easy anymore
     While we wait for crypto
* Objectives

  Can work offline, can be implemented cheap on receivers, trustless between Payers and Receivers, only trusted actor should be *Exchanges*, secure by using pubKey cryptography specially signatures.
  TODO: expand

* Actors
** Exchange

   A centralized entity that can exchange any money like (US$, credit card, bitcoins, etc) amount into *COINS* and back.
   This is the only actor that needs to be trusted by users.

   It's normal operation will be to sell *COINS* to *Payers* and buy *COINS* from *Receivers*.

   It can be implemented as a centralized server that receives credit card payments and gives back signed *COINS*.

   It also needs a set of places where people can fisically go obtain money by selling their *COINS*. This is important since most users of *Tipit* will now own
   a bank account.

   *Exchange* should keep track of what tokenId belongs to what userId (country id, creadit card, full name, etc)

** Payers

   Anybody that wants to tip. Can buy *COINS* from the *Exchange* and use them to tip *Receivers*.

   Can be implemented with a cellphone app that can buy *COINS* (in advance or online) from the *Exchange* and tip *Receivers* just buy using the cellphone.

** Receivers

   Anybody who receives tips. Can collect *COINS* from *Payers* and then exchange them for money by going to the *Exchange*.

   Can be implemented as any device that can at least :

   - exchange information with a cellphone (bluetooth, NFC, etc)
   - sign data
   - validate a cryptographyc signature
   - store *COINS* data

   A good implementation should have the devices needed by the *Receivers* implemented as cheapest as possible since not all people interested in tips can afford a cellphone.


* Tip Tokens and COINS

  *Tokens* are structured data that contains [TokenId, TokenValue, TokenCurrency]

  *COINS* are just *Tokens* signed by the *Payers* and then authorized (signed) by the *Exchange* before they can be used.

  Every token (then every coin) is meant to be used only once and then is banned forever. This rules are enforced by the *Exchange*.

  An example coin implementation can look like:
#+BEGIN_SRC javascript
  {
    token: {
      tokenId: "8a3e0ef9-b702-446d-a133-d0b091f1bdd3",
      value: 10,
      currency: "U$"
    },
    exchangeSignature: "..."
  }
#+END_SRC

  Probably a binary format is preferred so *Receivers* devices can be implemented with cheaper hardware.
** Token format
   TBD
** Coin format
   TDB

* Obtaining COINS

  For *Payers* to obtain *COINS* they first need to register in the *Exchange* with an id, credit card, and public key (generated by the app normally).

  When *Payers* wants to obtain *COINS* they first need to generate *Tokens* by choosing a value and a currency.

  *Tokens* are signed with the users public key and then sent to the *Exchange* together with the money to cover for their values.

  The *Exchange* can validate the token signature by using the registered user public key, and keep the signed token as a proof of request.

  The *Exchange* will track the users coin so if bad *Payers* try to double spend a token the *Exchange* will figure it out and resolve the problem.

  The last step for the *Exchange* before sending the coins back the user is to generate them by signing the *Tokens* with the *Exchange* private key which will correspond to the public key known by all *Receivers* devices.

** Request_Msg
   TBD
** Response_Msg
   TBD

* Paying (Tipping)

  The act of tipping is the act of transferring the *COINS* in the *Payers* device, to the *Receivers* device.

  This can be accomplished by any wireless communication system supported by both devices.

  When the transfer is complete the *Payers* device should show success.

* Receiving

  You receive a tip by offering the *Receivers* device to the *Payers* and wait for a confirmation.

  The *Receivers* device should first validate the *COINS* exchange signature and then store it if valid. Only when a valid coin is received the device should show a success light.

  At any moment *Receivers* can go to the *Exchange* and sell their *COINS* for money.

* Selling COINS

  For *Receivers* to sell *COINS* they first need to register in the *Exchange* with an id and public key.

  Before sending the *COINS* to the *Exchange* the *Receivers* device signs the coin with it private key which the *Exchange* will have to validate and keep as a sell proof.

  The *Exchange* will track every sold token in a blacklist so they can only be sold once.

* Implementation ideas
** Exchange server
   TBD
** Payers cellphone app
   TBD
** Receivers device
   TBD
